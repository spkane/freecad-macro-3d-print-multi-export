"""FreeCAD Macro: Multi-Format Export.

SPDX-License-Identifier: MIT
Copyright (c) 2025 Sean P. Kane (GitHub: spkane)

Export selected bodies to multiple file formats simultaneously with a
user-friendly dialog for format selection and output configuration.

Requirements:
    - FreeCAD 0.21 or later
    - One or more objects selected in the 3D view

Usage:
    1. Select the object(s) to export
    2. Run the macro
    3. Select desired export formats (STL, STEP, 3MF selected by default)
    4. Choose output directory and base filename
    5. Click "Export"
"""

# FreeCAD Addon Manager metadata
__Name__ = "Multi Export"
__Comment__ = (
    "Export selected bodies to multiple file formats (STL, STEP, 3MF, OBJ, IGES, BREP, PLY, AMF) simultaneously"
)
__Author__ = "Sean P. Kane"
__Version__ = "0.6.2"
__Date__ = "2026-01-17"
__License__ = "MIT"
__Web__ = "https://github.com/spkane/freecad-macro-3d-print-multi-export"
__Wiki__ = "https://github.com/spkane/freecad-macro-3d-print-multi-export#readme"
__Icon__ = ""
__Help__ = "Select one or more objects, run the macro, choose export formats and output location, then click Export."
__Status__ = "Beta"
__Requires__ = "FreeCAD 0.21+"
__Communication__ = "https://github.com/spkane/freecad-macro-3d-print-multi-export/issues"
__Files__ = ""

import os
import sys
from dataclasses import dataclass

import FreeCAD as App
import FreeCADGui as Gui
import Mesh
import Part
from PySide import QtGui

# Try to import from modules (when installed via Addon Manager with full package)
# Fall back to embedded definitions (when just the .FCMacro file is copied)
_USE_MODULES = False
_macro_dir = os.path.dirname(os.path.abspath(__file__))
if _macro_dir not in sys.path:
    sys.path.insert(0, _macro_dir)

try:
    from multi_export_core import (
        EXPORT_FORMATS,
        format_export_summary,
        sanitize_filename,
        validate_export_params,
    )
    from multi_export_fc import (
        MultiExporter,
        get_exportable_objects,
        get_object_type,
    )

    _USE_MODULES = True
except ImportError:
    # Modules not available - use embedded definitions below
    pass


# =============================================================================
# Embedded definitions (used when modules aren't available)
# =============================================================================

if not _USE_MODULES:

    @dataclass
    class ExportFormat:
        """Represents an export format with its properties."""

        name: str
        extension: str
        description: str
        default_enabled: bool = False

    EXPORT_FORMATS = [
        ExportFormat("STL", "stl", "Stereolithography - common for 3D printing", True),
        ExportFormat("STEP", "step", "Standard for Exchange of Product Data - CAD interchange", True),
        ExportFormat("3MF", "3mf", "3D Manufacturing Format - modern 3D printing format", True),
        ExportFormat("OBJ", "obj", "Wavefront OBJ - 3D graphics and game engines", False),
        ExportFormat("IGES", "iges", "Initial Graphics Exchange Specification - legacy CAD format", False),
        ExportFormat("BREP", "brep", "OpenCASCADE native format - preserves exact geometry", False),
        ExportFormat("PLY", "ply", "Polygon File Format - 3D scanning and printing", False),
        ExportFormat("AMF", "amf", "Additive Manufacturing Format - XML-based 3D printing", False),
    ]

    MESH_FORMATS = {"stl", "obj", "ply", "3mf", "amf"}

    def sanitize_filename(name: str) -> str:
        """Sanitize a string for use as a filename."""
        invalid_chars = '<>:"/\\|?*'
        result = name
        for char in invalid_chars:
            result = result.replace(char, "_")
        result = result.strip(" .")
        return result if result else "export"

    def validate_export_params(params: dict) -> list[str]:
        """Validate export parameters and return list of errors."""
        errors = []
        if not params.get("formats"):
            errors.append("No export formats selected")
        if not params.get("base_filename") or not params["base_filename"].strip():
            errors.append("No base filename provided")
        if not params.get("directory"):
            errors.append("No output directory specified")
        return errors

    def format_export_summary(exported_files: list[str], errors: list[str]) -> str:
        """Format a summary of export results for display."""
        lines = []
        if exported_files:
            lines.append(f"Successfully exported {len(exported_files)} file(s):")
            for f in exported_files[:5]:
                lines.append(f"  • {os.path.basename(f)}")
            if len(exported_files) > 5:
                lines.append(f"  ... and {len(exported_files) - 5} more")
        if errors:
            if lines:
                lines.append("")
            lines.append(f"Warnings ({len(errors)}):")
            for e in errors[:3]:
                lines.append(f"  • {e}")
        return "\n".join(lines) if lines else "No files exported"

    def get_object_type(obj) -> str:
        """Get a human-readable type description for an object."""
        if hasattr(obj, "TypeId"):
            type_id = obj.TypeId
            if "Part::" in type_id:
                return type_id.replace("Part::", "")
            if "PartDesign::" in type_id:
                return type_id.replace("PartDesign::", "")
            if "Mesh::" in type_id:
                return "Mesh"
            return type_id
        if hasattr(obj, "Shape"):
            return "Shape"
        return ""

    def get_exportable_objects(selection: list) -> list:
        """Filter selection to only include exportable objects."""
        exportable = []
        for obj in selection:
            if hasattr(obj, "Shape") and hasattr(obj.Shape, "Volume"):
                if obj.Shape.Volume > 0.001:
                    exportable.append(obj)
            elif hasattr(obj, "Mesh"):
                exportable.append(obj)
        return exportable

    class MultiExporter:
        """Handles exporting objects to multiple formats."""

        def __init__(self, objects: list, params: dict):
            self.objects = objects
            self.params = params
            self.exported_files = []
            self.errors = []

        def export_all(self, progress_callback=None) -> tuple[list[str], list[str]]:
            """Export objects to all selected formats."""
            formats = self.params["formats"]
            total_exports = len(formats)

            if total_exports == 0:
                return [], ["No formats selected"]

            for i, fmt in enumerate(formats):
                if progress_callback:
                    progress = int((i / total_exports) * 100)
                    progress_callback(progress, f"Exporting {fmt.upper()}...")

                try:
                    filepath = self._export_format(fmt)
                    self.exported_files.append(filepath)
                    App.Console.PrintMessage(f"Exported: {filepath}\n")
                except Exception as e:  # nosec B112
                    error_msg = f"Failed to export {fmt.upper()}: {e!s}"
                    self.errors.append(error_msg)
                    App.Console.PrintError(f"{error_msg}\n")

            if progress_callback:
                progress_callback(100, "Export complete!")

            return self.exported_files, self.errors

        def _export_format(self, extension: str) -> str:
            """Export to a specific format."""
            directory = self.params["directory"]
            base_name = self.params["base_filename"]
            filepath = os.path.join(directory, f"{base_name}.{extension}")

            shapes = []
            for obj in self.objects:
                if hasattr(obj, "Shape"):
                    shapes.append(obj.Shape)
                elif hasattr(obj, "Mesh"):
                    shapes.append(obj.Mesh)

            if not shapes:
                raise ValueError("No exportable shapes found")

            combined_shape = shapes[0] if len(shapes) == 1 else Part.makeCompound(shapes)

            if extension in MESH_FORMATS:
                self._export_mesh(combined_shape, filepath)
            elif extension == "step":
                combined_shape.exportStep(filepath)
            elif extension == "iges":
                combined_shape.exportIges(filepath)
            elif extension == "brep":
                combined_shape.exportBrep(filepath)
            else:
                raise ValueError(f"Unsupported format: {extension}")

            return filepath

        def _export_mesh(self, shape, filepath: str):
            """Export shape as a mesh format."""
            tolerance = self.params.get("mesh_tolerance", 0.1)
            mesh = Mesh.Mesh()

            if hasattr(shape, "tessellate"):
                vertices, facets = shape.tessellate(tolerance)
                mesh_data = []
                for facet in facets:
                    triangle = [vertices[facet[0]], vertices[facet[1]], vertices[facet[2]]]
                    mesh_data.append(triangle)
                mesh.addFacets(mesh_data)
            elif hasattr(shape, "Facets"):
                mesh = shape
            else:
                raise ValueError("Cannot create mesh from object")

            mesh.write(filepath)


# =============================================================================
# End of embedded definitions
# =============================================================================


class MultiExportDialog(QtGui.QDialog):
    """Dialog for configuring multi-format export options."""

    def __init__(self, selected_objects: list, parent=None):
        """Initialize the export dialog.

        Args:
            selected_objects: List of FreeCAD objects to export
            parent: Parent widget
        """
        super().__init__(parent)
        self.selected_objects = selected_objects
        self.format_checkboxes = {}

        self.setWindowTitle("Multi-Format Export")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.setup_ui()
        self.populate_defaults()

    def setup_ui(self):
        """Initialize the user interface."""
        layout = QtGui.QVBoxLayout()

        # Objects to export section
        objects_group = QtGui.QGroupBox("Objects to Export")
        objects_layout = QtGui.QVBoxLayout()

        self.objects_list = QtGui.QListWidget()
        self.objects_list.setMaximumHeight(100)
        self.objects_list.setSelectionMode(QtGui.QAbstractItemView.NoSelection)
        for obj in self.selected_objects:
            item = QtGui.QListWidgetItem(f"{obj.Label} ({get_object_type(obj)})")
            self.objects_list.addItem(item)
        objects_layout.addWidget(self.objects_list)

        objects_group.setLayout(objects_layout)
        layout.addWidget(objects_group)

        # Export formats section
        formats_group = QtGui.QGroupBox("Export Formats")
        formats_layout = QtGui.QGridLayout()

        for i, fmt in enumerate(EXPORT_FORMATS):
            checkbox = QtGui.QCheckBox(f"{fmt.name} (.{fmt.extension})")
            checkbox.setChecked(fmt.default_enabled)
            checkbox.setToolTip(fmt.description)
            self.format_checkboxes[fmt.extension] = checkbox

            row = i // 2
            col = i % 2
            formats_layout.addWidget(checkbox, row, col)

        # Quick selection buttons
        button_row = (len(EXPORT_FORMATS) + 1) // 2
        select_all_btn = QtGui.QPushButton("Select All")
        select_all_btn.clicked.connect(self._select_all_formats)
        select_none_btn = QtGui.QPushButton("Select None")
        select_none_btn.clicked.connect(self._select_no_formats)
        select_defaults_btn = QtGui.QPushButton("Reset Defaults")
        select_defaults_btn.clicked.connect(self._reset_default_formats)

        btn_layout = QtGui.QHBoxLayout()
        btn_layout.addWidget(select_all_btn)
        btn_layout.addWidget(select_none_btn)
        btn_layout.addWidget(select_defaults_btn)
        btn_layout.addStretch()

        formats_layout.addLayout(btn_layout, button_row, 0, 1, 2)

        formats_group.setLayout(formats_layout)
        layout.addWidget(formats_group)

        # Output configuration section
        output_group = QtGui.QGroupBox("Output Configuration")
        output_layout = QtGui.QFormLayout()

        # Directory selection
        dir_layout = QtGui.QHBoxLayout()
        self.directory_edit = QtGui.QLineEdit()
        self.directory_edit.setReadOnly(True)
        browse_btn = QtGui.QPushButton("Browse...")
        browse_btn.clicked.connect(self._browse_directory)
        dir_layout.addWidget(self.directory_edit)
        dir_layout.addWidget(browse_btn)
        output_layout.addRow("Directory:", dir_layout)

        # Base filename
        self.filename_edit = QtGui.QLineEdit()
        self.filename_edit.setToolTip("Base filename without extension. Each format will be appended.")
        output_layout.addRow("Base Filename:", self.filename_edit)

        # Preview of output files
        self.preview_label = QtGui.QLabel("")
        self.preview_label.setWordWrap(True)
        self.preview_label.setStyleSheet("color: gray; font-size: 11px;")
        output_layout.addRow("Will create:", self.preview_label)

        # Connect signals for preview updates
        self.filename_edit.textChanged.connect(self._update_preview)
        self.directory_edit.textChanged.connect(self._update_preview)
        for checkbox in self.format_checkboxes.values():
            checkbox.stateChanged.connect(self._update_preview)

        output_group.setLayout(output_layout)
        layout.addWidget(output_group)

        # Mesh options section (for STL, OBJ, PLY, 3MF, AMF)
        mesh_group = QtGui.QGroupBox("Mesh Options (STL, OBJ, PLY, 3MF, AMF)")
        mesh_layout = QtGui.QFormLayout()

        self.tolerance_spin = QtGui.QDoubleSpinBox()
        self.tolerance_spin.setRange(0.001, 10.0)
        self.tolerance_spin.setValue(0.1)
        self.tolerance_spin.setDecimals(3)
        self.tolerance_spin.setSuffix(" mm")
        self.tolerance_spin.setToolTip("Lower values create finer meshes but larger files")
        mesh_layout.addRow("Surface Tolerance:", self.tolerance_spin)

        self.deflection_spin = QtGui.QDoubleSpinBox()
        self.deflection_spin.setRange(0.001, 10.0)
        self.deflection_spin.setValue(0.1)
        self.deflection_spin.setDecimals(3)
        self.deflection_spin.setSuffix(" mm")
        self.deflection_spin.setToolTip("Angular deflection for curved surfaces")
        mesh_layout.addRow("Angular Deflection:", self.deflection_spin)

        mesh_group.setLayout(mesh_layout)
        layout.addWidget(mesh_group)

        # Status label
        self.status_label = QtGui.QLabel("")
        self.status_label.setWordWrap(True)
        layout.addWidget(self.status_label)

        # Progress bar (hidden initially)
        self.progress_bar = QtGui.QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Buttons
        button_box = QtGui.QDialogButtonBox()
        self.export_btn = button_box.addButton("Export", QtGui.QDialogButtonBox.AcceptRole)
        button_box.addButton(QtGui.QDialogButtonBox.Cancel)

        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        layout.addWidget(button_box)
        self.setLayout(layout)

    def populate_defaults(self):
        """Populate default values based on the current document."""
        doc = App.ActiveDocument

        # Default directory: same as the FreeCAD document
        if doc and doc.FileName:
            default_dir = os.path.dirname(doc.FileName)
        else:
            default_dir = os.path.expanduser("~")
        self.directory_edit.setText(default_dir)

        # Default filename: based on selected objects or document name
        if len(self.selected_objects) == 1:
            # Single object: use its label
            default_name = sanitize_filename(self.selected_objects[0].Label)
        elif doc and doc.FileName:
            # Multiple objects: use document name
            doc_name = os.path.splitext(os.path.basename(doc.FileName))[0]
            default_name = sanitize_filename(doc_name)
        elif doc:
            default_name = sanitize_filename(doc.Label)
        else:
            default_name = "export"

        self.filename_edit.setText(default_name)
        self._update_preview()

    def _select_all_formats(self):
        """Select all export formats."""
        for checkbox in self.format_checkboxes.values():
            checkbox.setChecked(True)

    def _select_no_formats(self):
        """Deselect all export formats."""
        for checkbox in self.format_checkboxes.values():
            checkbox.setChecked(False)

    def _reset_default_formats(self):
        """Reset to default format selection."""
        for fmt in EXPORT_FORMATS:
            self.format_checkboxes[fmt.extension].setChecked(fmt.default_enabled)

    def _browse_directory(self):
        """Open directory browser dialog."""
        current_dir = self.directory_edit.text() or os.path.expanduser("~")
        directory = QtGui.QFileDialog.getExistingDirectory(
            self,
            "Select Export Directory",
            current_dir,
            QtGui.QFileDialog.ShowDirsOnly,
        )
        if directory:
            self.directory_edit.setText(directory)

    def _update_preview(self):
        """Update the preview of files to be created."""
        selected_formats = self.get_selected_formats()
        base_name = self.filename_edit.text().strip()

        if not selected_formats:
            self.preview_label.setText("No formats selected")
            return

        if not base_name:
            self.preview_label.setText("Enter a filename")
            return

        files = [f"{base_name}.{ext}" for ext in selected_formats]
        if len(files) > 4:
            preview_text = ", ".join(files[:4]) + f", ... (+{len(files) - 4} more)"
        else:
            preview_text = ", ".join(files)

        self.preview_label.setText(preview_text)

    def get_selected_formats(self) -> list[str]:
        """Get list of selected format extensions."""
        return [ext for ext, checkbox in self.format_checkboxes.items() if checkbox.isChecked()]

    def get_export_parameters(self) -> dict:
        """Get all export parameters from the dialog."""
        return {
            "directory": self.directory_edit.text(),
            "base_filename": self.filename_edit.text().strip(),
            "formats": self.get_selected_formats(),
            "mesh_tolerance": self.tolerance_spin.value(),
            "mesh_deflection": self.deflection_spin.value(),
        }

    def set_status(self, message: str, is_error: bool = False):
        """Update status message."""
        if is_error:
            self.status_label.setStyleSheet("color: red;")
        else:
            self.status_label.setStyleSheet("color: green;")
        self.status_label.setText(message)
        QtGui.QApplication.processEvents()

    def set_progress(self, value: int, maximum: int = 100):
        """Update progress bar."""
        if not self.progress_bar.isVisible():
            self.progress_bar.setVisible(True)
        self.progress_bar.setMaximum(maximum)
        self.progress_bar.setValue(value)
        QtGui.QApplication.processEvents()


def main():
    """Main macro entry point."""
    # Check for active document
    if not App.ActiveDocument:
        QtGui.QMessageBox.warning(None, "No Document", "Please open or create a document first.")
        return

    # Get current selection
    selection = Gui.Selection.getSelection()

    if not selection:
        QtGui.QMessageBox.warning(
            None,
            "No Selection",
            "Please select one or more objects to export.\n\n"
            "You can select multiple objects by holding Ctrl/Cmd while clicking.",
        )
        return

    # Filter to exportable objects
    exportable = get_exportable_objects(selection)

    if not exportable:
        QtGui.QMessageBox.warning(
            None,
            "No Exportable Objects",
            "None of the selected objects can be exported.\n\n"
            "Please select objects with solid shapes (Part or PartDesign bodies).",
        )
        return

    # Show dialog
    dialog = MultiExportDialog(exportable)

    if dialog.exec_() != QtGui.QDialog.Accepted:
        return

    params = dialog.get_export_parameters()

    # Validate parameters using core module
    errors = validate_export_params(params)
    if not os.path.isdir(params["directory"]):
        errors.append(f"Directory does not exist: {params['directory']}")

    if errors:
        QtGui.QMessageBox.warning(
            None,
            "Invalid Parameters",
            "\n".join(errors),
        )
        return

    # Perform export
    try:
        exporter = MultiExporter(exportable, params)

        def progress_update(value, message=""):
            dialog.set_status(message)
            dialog.set_progress(value)

        exported_files, export_errors = exporter.export_all(progress_update)

        # Show results using core module's formatter
        summary = format_export_summary(exported_files, export_errors)

        if exported_files:
            dialog.set_status(summary)
            App.Console.PrintMessage(f"Multi-export complete: {len(exported_files)} files\n")
        else:
            dialog.set_status(summary, is_error=True)
            App.Console.PrintError(f"Multi-export failed: {export_errors}\n")

    except Exception as e:  # nosec B112
        dialog.set_status(f"Export error: {e!s}", is_error=True)
        App.Console.PrintError(f"Multi-export error: {e!s}\n")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()
